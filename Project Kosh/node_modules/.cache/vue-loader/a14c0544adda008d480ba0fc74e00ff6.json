{"remainingRequest":"/Users/murphyren/Desktop/170/nn/final-project-team-peach/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/murphyren/Desktop/170/nn/final-project-team-peach/node_modules/vue2-gmap-custom-marker/gmap-custom-marker.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/murphyren/Desktop/170/nn/final-project-team-peach/node_modules/vue2-gmap-custom-marker/gmap-custom-marker.vue","mtime":499162500000},{"path":"/Users/murphyren/Desktop/170/nn/final-project-team-peach/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/murphyren/Desktop/170/nn/final-project-team-peach/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/Users/murphyren/Desktop/170/nn/final-project-team-peach/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/murphyren/Desktop/170/nn/final-project-team-peach/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KCmltcG9ydCAqIGFzIFZ1ZUdvb2dsZU1hcHMgZnJvbSAiZ21hcC12dWUiOwpleHBvcnQgZGVmYXVsdCB7CiAgbWl4aW5zOiBbVnVlR29vZ2xlTWFwcy5NYXBFbGVtZW50TWl4aW5dLAogIHByb3BzOiB7CiAgICBtYXJrZXI6IHsKICAgICAgdHlwZTogT2JqZWN0LAogICAgICBkZWZhdWx0OiB1bmRlZmluZWQKICAgIH0sCiAgICBvZmZzZXRYOiB7CiAgICAgIHR5cGU6IE51bWJlciwKICAgICAgZGVmYXVsdDogMAogICAgfSwKICAgIG9mZnNldFk6IHsKICAgICAgdHlwZTogTnVtYmVyLAogICAgICBkZWZhdWx0OiAwCiAgICB9LAogICAgYWxpZ25tZW50OiB7CiAgICAgIHR5cGU6IFN0cmluZywKICAgICAgZGVmYXVsdDogInRvcCIKICAgIH0sCiAgICB6SW5kZXg6IHsKICAgICAgdHlwZTogTnVtYmVyLAogICAgICBkZWZhdWx0OiA1MAogICAgfSwKICAgIGNzc1Bvc2l0aW9uOiB7CiAgICAgIHR5cGU6IEJvb2xlYW4sCiAgICAgIGRlZmF1bHQ6IGZhbHNlCiAgICB9CiAgfSwKICBpbmplY3Q6IHsKICAgICRjbHVzdGVyUHJvbWlzZTogewogICAgICBkZWZhdWx0OiBudWxsCiAgICB9CiAgfSwKICBiZWZvcmVDcmVhdGUgKG9wdGlvbnMpIHsKICAgIGlmICh0aGlzLiRjbHVzdGVyUHJvbWlzZSkgewogICAgICBvcHRpb25zLm1hcCA9IG51bGw7CiAgICB9CgogICAgcmV0dXJuIHRoaXMuJGNsdXN0ZXJQcm9taXNlOwogIH0sCiAgbWV0aG9kczogewogICAgYWZ0ZXJDcmVhdGUgKGluc3QpIHsKICAgICAgaWYgKHRoaXMuJGNsdXN0ZXJQcm9taXNlICYmICF0aGlzLmlzTWFya2VyQWRkZWQpIHsKICAgICAgICB0aGlzLiRjbHVzdGVyUHJvbWlzZS50aGVuKGNvID0+IHsKICAgICAgICAgIGNvLmFkZE1hcmtlcihpbnN0KTsKICAgICAgICAgIHRoaXMuJGNsdXN0ZXJPYmplY3QgPSBjbzsKICAgICAgICAgIHRoaXMuaXNNYXJrZXJBZGRlZCA9IHRydWU7CiAgICAgICAgfSk7CiAgICAgIH0KICAgIH0KICB9LAogIGRhdGEgKCkgewogICAgcmV0dXJuIHsKICAgICAgb3BhY2l0eTogMC4wMQogICAgfTsKICB9LAogIHdhdGNoOiB7CiAgICBtYXJrZXIgKHZhbCkgewogICAgICB0aGlzLiRtYXBQcm9taXNlLnRoZW4obWFwID0+IHRoaXMuJG92ZXJsYXkuc2V0UG9zaXRpb24oKSk7CiAgICB9LAogICAgekluZGV4ICh2YWwpIHsKICAgICAgaWYgKHRoaXMuJG92ZXJsYXkpIHsKICAgICAgICB0aGlzLiRvdmVybGF5LnJlcGFpbnQoKQogICAgICB9CiAgICB9CiAgfSwKICBwcm92aWRlICgpIHsKICAgIGNvbnN0IHNlbGYgPSB0aGlzOwogICAgcmV0dXJuIHRoaXMuJG1hcFByb21pc2UudGhlbihtYXAgPT4gewogICAgICBjbGFzcyBPdmVybGF5IGV4dGVuZHMgZ29vZ2xlLm1hcHMuT3ZlcmxheVZpZXcgewogICAgICAgIGNvbnN0cnVjdG9yKG1hcCkgewogICAgICAgICAgc3VwZXIoKTsKICAgICAgICAgIHRoaXMuc2V0TWFwKG1hcCk7CiAgICAgICAgICB0aGlzLmRyYXcgPSAoKSA9PiB0aGlzLnJlcGFpbnQoKTsKICAgICAgICAgIHRoaXMuc2V0UG9zaXRpb24gPSAoKSA9PiB0aGlzLnJlcGFpbnQoKTsKICAgICAgICB9CiAgICAgICAgcmVwYWludCAoKSB7CiAgICAgICAgICBjb25zdCBkaXYgPSBzZWxmLiRlbDsKICAgICAgICAgIGNvbnN0IHByb2plY3Rpb24gPSB0aGlzLmdldFByb2plY3Rpb24oKTsKICAgICAgICAgIGlmIChwcm9qZWN0aW9uICYmIGRpdikgewogICAgICAgICAgICBjb25zdCBwb3NQaXhlbCA9IHByb2plY3Rpb24uZnJvbUxhdExuZ1RvRGl2UGl4ZWwoc2VsZi5sYXRMbmcpOwogICAgICAgICAgICBsZXQgeCwgeTsKICAgICAgICAgICAgc3dpdGNoIChzZWxmLmFsaWdubWVudCkgewogICAgICAgICAgICAgIGNhc2UgInRvcCI6CiAgICAgICAgICAgICAgICB4ID0gcG9zUGl4ZWwueCAtIGRpdi5vZmZzZXRXaWR0aCAvIDI7CiAgICAgICAgICAgICAgICB5ID0gcG9zUGl4ZWwueSAtIGRpdi5vZmZzZXRIZWlnaHQ7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICBjYXNlICJib3R0b20iOgogICAgICAgICAgICAgICAgeCA9IHBvc1BpeGVsLnggLSBkaXYub2Zmc2V0V2lkdGggLyAyOwogICAgICAgICAgICAgICAgeSA9IHBvc1BpeGVsLnk7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICBjYXNlICJsZWZ0IjoKICAgICAgICAgICAgICAgIHggPSBwb3NQaXhlbC54IC0gZGl2Lm9mZnNldFdpZHRoOwogICAgICAgICAgICAgICAgeSA9IHBvc1BpeGVsLnkgLSBkaXYub2Zmc2V0SGVpZ2h0IC8gMjsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIGNhc2UgInJpZ2h0IjoKICAgICAgICAgICAgICAgIHggPSBwb3NQaXhlbC54OwogICAgICAgICAgICAgICAgeSA9IHBvc1BpeGVsLnkgLSBkaXYub2Zmc2V0SGVpZ2h0IC8gMjsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIGNhc2UgImNlbnRlciI6CiAgICAgICAgICAgICAgICB4ID0gcG9zUGl4ZWwueCAtIGRpdi5vZmZzZXRXaWR0aCAvIDI7CiAgICAgICAgICAgICAgICB5ID0gcG9zUGl4ZWwueSAtIGRpdi5vZmZzZXRIZWlnaHQgLyAyOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgY2FzZSAidG9wbGVmdCI6CiAgICAgICAgICAgICAgY2FzZSAibGVmdHRvcCI6CiAgICAgICAgICAgICAgICB4ID0gcG9zUGl4ZWwueCAtIGRpdi5vZmZzZXRXaWR0aDsKICAgICAgICAgICAgICAgIHkgPSBwb3NQaXhlbC55IC0gZGl2Lm9mZnNldEhlaWdodDsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIGNhc2UgInRvcHJpZ2h0IjoKICAgICAgICAgICAgICBjYXNlICJyaWdodHRvcCI6CiAgICAgICAgICAgICAgICB4ID0gcG9zUGl4ZWwueDsKICAgICAgICAgICAgICAgIHkgPSBwb3NQaXhlbC55IC0gZGl2Lm9mZnNldEhlaWdodDsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgIGNhc2UgImJvdHRvbWxlZnQiOgogICAgICAgICAgICAgIGNhc2UgImxlZnRvcCI6CiAgICAgICAgICAgICAgICB4ID0gcG9zUGl4ZWwueCAtIGRpdi5vZmZzZXRXaWR0aDsKICAgICAgICAgICAgICAgIHkgPSBwb3NQaXhlbC55OwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgY2FzZSAiYm90dG9tcmlnaHQiOgogICAgICAgICAgICAgIGNhc2UgInJpZ2h0Ym90dG9tIjoKICAgICAgICAgICAgICAgIHggPSBwb3NQaXhlbC54OwogICAgICAgICAgICAgICAgeSA9IHBvc1BpeGVsLnk7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgICBkZWZhdWx0OgogICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIGFsaWdubWVudCB0eXBlIG9mIGN1c3RvbSBtYXJrZXIhIik7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoc2VsZi5jc3NQb3NpdGlvbikgewogICAgICAgICAgICAgIGRpdi5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7eCArIHNlbGYub2Zmc2V0WH1weCwgJHt5ICsgc2VsZi5vZmZzZXRZfXB4KWA7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgZGl2LnN0eWxlLmxlZnQgPSB4ICsgc2VsZi5vZmZzZXRYICsgInB4IjsKICAgICAgICAgICAgICBkaXYuc3R5bGUudG9wID0geSArIHNlbGYub2Zmc2V0WSArICJweCI7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZGl2LnN0eWxlWyJ6LWluZGV4Il0gPSBzZWxmLnpJbmRleDsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgb25BZGQgKCkgewogICAgICAgICAgY29uc3QgZGl2ID0gc2VsZi4kZWw7CiAgICAgICAgICBjb25zdCBwYW5lcyA9IHRoaXMuZ2V0UGFuZXMoKTsKICAgICAgICAgIGRpdi5zdHlsZS5wb3NpdGlvbiA9ICJhYnNvbHV0ZSI7CiAgICAgICAgICBkaXYuc3R5bGUuZGlzcGxheSA9ICJpbmxpbmUtYmxvY2siOwogICAgICAgICAgZGl2LnN0eWxlLnpJbmRleCA9IHNlbGYuekluZGV4OwogICAgICAgICAgcGFuZXMub3ZlcmxheUxheWVyLmFwcGVuZENoaWxkKGRpdik7CiAgICAgICAgICBwYW5lcy5vdmVybGF5TW91c2VUYXJnZXQuYXBwZW5kQ2hpbGQoZGl2KTsKICAgICAgICAgIHRoaXMuZ2V0RHJhZ2dhYmxlID0gKCkgPT4gZmFsc2U7CiAgICAgICAgICB0aGlzLmdldFBvc2l0aW9uID0gKCkgPT4gewogICAgICAgICAgICByZXR1cm4gbmV3IGdvb2dsZS5tYXBzLkxhdExuZyhzZWxmLmxhdCwgc2VsZi5sbmcpOwogICAgICAgICAgfTsKICAgICAgICAgIHNlbGYuYWZ0ZXJDcmVhdGUodGhpcyk7CiAgICAgICAgfQogICAgICAgIG9uUmVtb3ZlICgpIHsKICAgICAgICAgIGlmIChzZWxmLiRlbCkgewogICAgICAgICAgICBjb25zdCB1YSA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50CiAgICAgICAgICAgIGNvbnN0IG1zaWUgPSB1YS5pbmRleE9mKCJNU0lFICIpCiAgICAgICAgICAgIGlmIChtc2llID4gMCB8fCAhIXVhLm1hdGNoKC9UcmlkZW50Lipydlw6MTFcLi8pKSB7CiAgICAgICAgICAgICAgc2VsZi4kZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzZWxmLiRlbCkKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBzZWxmLiRlbC5yZW1vdmUoKTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICB0aGlzLiRvdmVybGF5ID0gbmV3IE92ZXJsYXkobWFwKTsKICAgICAgc2V0VGltZW91dCgoKSA9PiB7CiAgICAgICAgaWYgKHRoaXMuJG92ZXJsYXkpIHsKICAgICAgICAgIHRoaXMuJG92ZXJsYXkucmVwYWludCgpOwogICAgICAgICAgdGhpcy5vcGFjaXR5ID0gMTsKICAgICAgICB9CiAgICAgIH0sIDEwMCk7CiAgICB9KTsKICB9LAogIGNvbXB1dGVkOiB7CiAgICBsYXQgKCkgewogICAgICByZXR1cm4gcGFyc2VGbG9hdCgKICAgICAgICBpc05hTih0aGlzLm1hcmtlci5sYXQpID8gdGhpcy5tYXJrZXIubGF0aXR1ZGUgOiB0aGlzLm1hcmtlci5sYXQKICAgICAgKTsKICAgIH0sCiAgICBsbmcgKCkgewogICAgICByZXR1cm4gcGFyc2VGbG9hdCgKICAgICAgICBpc05hTih0aGlzLm1hcmtlci5sbmcpID8gdGhpcy5tYXJrZXIubG9uZ2l0dWRlIDogdGhpcy5tYXJrZXIubG5nCiAgICAgICk7CiAgICB9LAogICAgbGF0TG5nICgpIHsKICAgICAgaWYgKHRoaXMubWFya2VyIGluc3RhbmNlb2YgZ29vZ2xlLm1hcHMuTGF0TG5nKSB7CiAgICAgICAgcmV0dXJuIHRoaXMubWFya2VyOwogICAgICB9CiAgICAgIHJldHVybiBuZXcgZ29vZ2xlLm1hcHMuTGF0TG5nKHRoaXMubGF0LCB0aGlzLmxuZyk7CiAgICB9CiAgfSwKICBkZXN0cm95ZWQgKCkgewogICAgaWYgKHRoaXMuJGNsdXN0ZXJPYmplY3QpIHsKICAgICAgdGhpcy4kY2x1c3Rlck9iamVjdC5yZW1vdmVNYXJrZXIodGhpcy4kb3ZlcmxheSwgdHJ1ZSk7CiAgICB9IGVsc2UgewogICAgICB0aGlzLiRvdmVybGF5LnNldE1hcChudWxsKTsKICAgICAgdGhpcy4kb3ZlcmxheSA9IHVuZGVmaW5lZDsKICAgIH0KICB9Cn07Cg=="},{"version":3,"sources":["gmap-custom-marker.vue"],"names":[],"mappings":";;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"gmap-custom-marker.vue","sourceRoot":"node_modules/vue2-gmap-custom-marker","sourcesContent":["<template>\n  <div :style=\"{opacity: opacity}\">\n    <slot />\n  </div>\n</template>\n<script>\n  import * as VueGoogleMaps from \"gmap-vue\";\n  export default {\n    mixins: [VueGoogleMaps.MapElementMixin],\n    props: {\n      marker: {\n        type: Object,\n        default: undefined\n      },\n      offsetX: {\n        type: Number,\n        default: 0\n      },\n      offsetY: {\n        type: Number,\n        default: 0\n      },\n      alignment: {\n        type: String,\n        default: \"top\"\n      },\n      zIndex: {\n        type: Number,\n        default: 50\n      },\n      cssPosition: {\n        type: Boolean,\n        default: false\n      }\n    },\n    inject: {\n      $clusterPromise: {\n        default: null\n      }\n    },\n    beforeCreate (options) {\n      if (this.$clusterPromise) {\n        options.map = null;\n      }\n\n      return this.$clusterPromise;\n    },\n    methods: {\n      afterCreate (inst) {\n        if (this.$clusterPromise && !this.isMarkerAdded) {\n          this.$clusterPromise.then(co => {\n            co.addMarker(inst);\n            this.$clusterObject = co;\n            this.isMarkerAdded = true;\n          });\n        }\n      }\n    },\n    data () {\n      return {\n        opacity: 0.01\n      };\n    },\n    watch: {\n      marker (val) {\n        this.$mapPromise.then(map => this.$overlay.setPosition());\n      },\n      zIndex (val) {\n        if (this.$overlay) {\n          this.$overlay.repaint()\n        }\n      }\n    },\n    provide () {\n      const self = this;\n      return this.$mapPromise.then(map => {\n        class Overlay extends google.maps.OverlayView {\n          constructor(map) {\n            super();\n            this.setMap(map);\n            this.draw = () => this.repaint();\n            this.setPosition = () => this.repaint();\n          }\n          repaint () {\n            const div = self.$el;\n            const projection = this.getProjection();\n            if (projection && div) {\n              const posPixel = projection.fromLatLngToDivPixel(self.latLng);\n              let x, y;\n              switch (self.alignment) {\n                case \"top\":\n                  x = posPixel.x - div.offsetWidth / 2;\n                  y = posPixel.y - div.offsetHeight;\n                  break;\n                case \"bottom\":\n                  x = posPixel.x - div.offsetWidth / 2;\n                  y = posPixel.y;\n                  break;\n                case \"left\":\n                  x = posPixel.x - div.offsetWidth;\n                  y = posPixel.y - div.offsetHeight / 2;\n                  break;\n                case \"right\":\n                  x = posPixel.x;\n                  y = posPixel.y - div.offsetHeight / 2;\n                  break;\n                case \"center\":\n                  x = posPixel.x - div.offsetWidth / 2;\n                  y = posPixel.y - div.offsetHeight / 2;\n                  break;\n                case \"topleft\":\n                case \"lefttop\":\n                  x = posPixel.x - div.offsetWidth;\n                  y = posPixel.y - div.offsetHeight;\n                  break;\n                case \"topright\":\n                case \"righttop\":\n                  x = posPixel.x;\n                  y = posPixel.y - div.offsetHeight;\n                  break;\n                case \"bottomleft\":\n                case \"leftop\":\n                  x = posPixel.x - div.offsetWidth;\n                  y = posPixel.y;\n                  break;\n                case \"bottomright\":\n                case \"rightbottom\":\n                  x = posPixel.x;\n                  y = posPixel.y;\n                  break;\n                default:\n                  throw new Error(\"Invalid alignment type of custom marker!\");\n                  break;\n              }\n              if (self.cssPosition) {\n                div.style.transform = `translate(${x + self.offsetX}px, ${y + self.offsetY}px)`;\n              } else {\n                div.style.left = x + self.offsetX + \"px\";\n                div.style.top = y + self.offsetY + \"px\";\n              }\n              div.style[\"z-index\"] = self.zIndex;\n            }\n          }\n          onAdd () {\n            const div = self.$el;\n            const panes = this.getPanes();\n            div.style.position = \"absolute\";\n            div.style.display = \"inline-block\";\n            div.style.zIndex = self.zIndex;\n            panes.overlayLayer.appendChild(div);\n            panes.overlayMouseTarget.appendChild(div);\n            this.getDraggable = () => false;\n            this.getPosition = () => {\n              return new google.maps.LatLng(self.lat, self.lng);\n            };\n            self.afterCreate(this);\n          }\n          onRemove () {\n            if (self.$el) {\n              const ua = window.navigator.userAgent\n              const msie = ua.indexOf(\"MSIE \")\n              if (msie > 0 || !!ua.match(/Trident.*rv\\:11\\./)) {\n                self.$el.parentNode.removeChild(self.$el)\n              } else {\n                self.$el.remove();\n              }\n            }\n          }\n        }\n        this.$overlay = new Overlay(map);\n        setTimeout(() => {\n          if (this.$overlay) {\n            this.$overlay.repaint();\n            this.opacity = 1;\n          }\n        }, 100);\n      });\n    },\n    computed: {\n      lat () {\n        return parseFloat(\n          isNaN(this.marker.lat) ? this.marker.latitude : this.marker.lat\n        );\n      },\n      lng () {\n        return parseFloat(\n          isNaN(this.marker.lng) ? this.marker.longitude : this.marker.lng\n        );\n      },\n      latLng () {\n        if (this.marker instanceof google.maps.LatLng) {\n          return this.marker;\n        }\n        return new google.maps.LatLng(this.lat, this.lng);\n      }\n    },\n    destroyed () {\n      if (this.$clusterObject) {\n        this.$clusterObject.removeMarker(this.$overlay, true);\n      } else {\n        this.$overlay.setMap(null);\n        this.$overlay = undefined;\n      }\n    }\n  };\n</script>\n"]}]}